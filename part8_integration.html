<h2>🔄 Part 8 – How It All Works Together</h2>
<p><em>From the “Full-Stack Annotated Study Guide: Game Catalogue PWA (SQLite + Node.js + HTML/CSS/JS)”</em></p>
<hr>
<h3>🎯 Goal</h3>
<p>Understand the <strong>complete flow</strong> of how the Game Catalogue PWA operates — from user interaction to database query — and how to deploy it as a lightweight, installable web app.</p>
<p>💡 <strong>Analogy:</strong>
Think of your system as a <strong>restaurant workflow</strong>:</p>
<ul>
<li>The <strong>frontend</strong> is the waiter (takes orders from users)</li>
<li>The <strong>backend</strong> is the chef (processes and prepares data)</li>
<li>The <strong>database</strong> is the pantry (stores all ingredients)</li>
</ul>
<hr>
<h2>🧠 1. The Full Architecture</h2>
<p>Here’s the logical overview of the entire system:</p>
<pre><code>+------------------------+
|      Frontend UI       |
|  HTML + CSS + JS (PWA) |
|------------------------|
|  - Displays games list |
|  - Handles navigation  |
|  - Registers service   |
|    worker for offline  |
+-----------|------------+
            |
            v
+------------------------+
|       Backend API      |
|   Node.js + Express.js  |
|------------------------|
|  - Listens on port 3000 |
|  - Serves HTML &amp; JS     |
|  - Handles /api routes  |
|  - Queries SQLite DB    |
+-----------|------------+
            |
            v
+------------------------+
|      SQLite Database   |
|    games.db + schema   |
|------------------------|
|  - Stores games info    |
|  - Tables: games,       |
|    genres, platforms    |
|  - Returns query data   |
+------------------------+
</code></pre>
<p>💡 <strong>Key Point:</strong>
All three components live locally — no internet or external server is required, making it ideal for classroom projects or demos.</p>
<hr>
<h2>⚙️ 2. Request Flow (Step-by-Step)</h2>
<table>
<thead>
<tr>
<th>Step</th>
<th>Action</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>1️⃣</td>
<td>User opens <code>catalogue.html</code> in browser</td>
<td>Browser loads frontend UI</td>
</tr>
<tr>
<td>2️⃣</td>
<td><code>ui.js</code> calls <code>fetchGames()</code></td>
<td>JavaScript requests <code>/api/games</code></td>
</tr>
<tr>
<td>3️⃣</td>
<td>Express handles route <code>/api/games</code></td>
<td>Runs <code>db.all(&#39;SELECT * FROM games&#39;)</code></td>
</tr>
<tr>
<td>4️⃣</td>
<td>SQLite returns result rows</td>
<td>JSON array sent back to browser</td>
</tr>
<tr>
<td>5️⃣</td>
<td><code>ui.js</code> receives data</td>
<td>Builds HTML cards dynamically</td>
</tr>
<tr>
<td>6️⃣</td>
<td>User views games on screen</td>
<td>Data displayed beautifully in the grid layout</td>
</tr>
</tbody></table>
<p>💡 <strong>Tip:</strong>
This architecture is called a <strong>three-tier application</strong> — Presentation (UI), Logic (API), and Data (DB).</p>
<hr>
<h2>🚀 3. Progressive Web App (PWA) Features</h2>
<p>PWAs behave like <strong>installable native apps</strong> using just web technologies.
Your app already has the core PWA files:</p>
<table>
<thead>
<tr>
<th>File</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><code>manifest.json</code></td>
<td>Defines app name, icons, theme color, start page</td>
</tr>
<tr>
<td><code>service-worker.js</code></td>
<td>Handles caching, offline mode, and updates</td>
</tr>
</tbody></table>
<hr>
<h3>📱 Example: <code>manifest.json</code></h3>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;Game Catalogue PWA&quot;,
  &quot;short_name&quot;: &quot;GameCat&quot;,
  &quot;start_url&quot;: &quot;index.html&quot;,
  &quot;display&quot;: &quot;standalone&quot;,
  &quot;background_color&quot;: &quot;#ffffff&quot;,
  &quot;theme_color&quot;: &quot;#0d6efd&quot;,
  &quot;icons&quot;: [
    {
      &quot;src&quot;: &quot;icons/icon-192.png&quot;,
      &quot;sizes&quot;: &quot;192x192&quot;,
      &quot;type&quot;: &quot;image/png&quot;
    },
    {
      &quot;src&quot;: &quot;icons/icon-512.png&quot;,
      &quot;sizes&quot;: &quot;512x512&quot;,
      &quot;type&quot;: &quot;image/png&quot;
    }
  ]
}
</code></pre>
<p>💡 <strong>Note:</strong>
Once this is registered in your HTML <code>&lt;head&gt;</code> and your service worker runs, browsers will allow users to <strong>“Install App”</strong> like a native application.</p>
<hr>
<h3>⚙️ Example: <code>service-worker.js</code></h3>
<pre><code class="language-js">// =====================================================
//  service-worker.js – Offline caching for the PWA
// =====================================================

const CACHE_NAME = &#39;game-catalogue-v1&#39;;
const urlsToCache = [
  &#39;/&#39;,
  &#39;/index.html&#39;,
  &#39;/catalogue.html&#39;,
  &#39;/about.html&#39;,
  &#39;/css/style.css&#39;,
  &#39;/js/app.js&#39;,
  &#39;/js/ui.js&#39;,
  &#39;/js/database.js&#39;
];

// Install event – cache core files
self.addEventListener(&#39;install&#39;, (event) =&gt; {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache =&gt; cache.addAll(urlsToCache))
  );
  console.log(&#39; Service Worker installed&#39;);
});

// Fetch event – serve from cache or fetch network
self.addEventListener(&#39;fetch&#39;, (event) =&gt; {
  event.respondWith(
    caches.match(event.request)
      .then(response =&gt; response || fetch(event.request))
  );
});
</code></pre>
<p>💡 <strong>Tip:</strong>
When offline, cached pages still load — this is what makes your PWA usable without internet access.</p>
<hr>
<h2>🧩 4. Local Deployment &amp; Testing</h2>
<h3>🧪 Run the Backend</h3>
<pre><code class="language-bash">node server.js
</code></pre>
<p>✅ Server runs at → <a href="http://localhost:3000">http://localhost:3000</a></p>
<h3>🌐 Test API Endpoint</h3>
<p>Visit → [<a href="http://localhost:3000/api/games%5D">http://localhost:3000/api/games]</a>
You should see JSON data output like:</p>
<pre><code class="language-json">[
  { &quot;title&quot;: &quot;The Witcher 3&quot;, &quot;rating&quot;: 9.8 },
  { &quot;title&quot;: &quot;God of War&quot;, &quot;rating&quot;: 9.6 }
]
</code></pre>
<h3>💻 Launch Frontend</h3>
<p>Use VS Code’s <strong>Live Server</strong> extension:</p>
<ul>
<li>Right-click <code>index.html</code></li>
<li>Choose “Open with Live Server”</li>
</ul>
<p>Your app should display the game list dynamically, pulling data from your local Express + SQLite backend.</p>
<hr>
<h2>☁️ 5. Optional Deployment Options</h2>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Use Case</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Render.com / Railway.app</strong></td>
<td>Free Node.js hosting</td>
<td>Quick public demo</td>
</tr>
<tr>
<td><strong>Vercel / Netlify</strong></td>
<td>Frontend hosting only (static HTML/JS)</td>
<td>Split API + UI deployment</td>
</tr>
<tr>
<td><strong>Heroku / Fly.io</strong></td>
<td>Full-stack hosting (Express + DB)</td>
<td>Small-scale public app</td>
</tr>
<tr>
<td><strong>Local Server (Node)</strong></td>
<td>Run locally for classroom use</td>
<td>Fastest setup for students</td>
</tr>
</tbody></table>
<p>💡 <strong>Note:</strong>
If you deploy online, switch to <strong>a cloud database</strong> (like PostgreSQL) or use <strong>SQLite file persistence</strong> carefully (since some hosts reset files).</p>
<hr>
<h2>🧠 6. Best Practices Recap</h2>
<table>
<thead>
<tr>
<th>Category</th>
<th>Best Practice</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Database</strong></td>
<td>Normalize tables; use foreign keys properly</td>
</tr>
<tr>
<td><strong>Backend</strong></td>
<td>Use async/await and error handling</td>
</tr>
<tr>
<td><strong>Frontend</strong></td>
<td>Separate logic (UI, API, Styles) cleanly</td>
</tr>
<tr>
<td><strong>PWA</strong></td>
<td>Cache assets selectively to avoid stale data</td>
</tr>
<tr>
<td><strong>Version Control</strong></td>
<td>Commit small, frequent changes with clear messages</td>
</tr>
</tbody></table>
<p>💡 <strong>Example Commit Message:</strong></p>
<pre><code>feat: add API route for fetching games by platform
fix: corrected rating column type in schema.sql
</code></pre>
<hr>
<h2>🧩 7. What You’ve Built</h2>
<p>✅ A <strong>complete full-stack application</strong> including:</p>
<ul>
<li>Automated setup via Bash script</li>
<li>Express.js + SQLite backend</li>
<li>Responsive HTML/CSS + JavaScript frontend</li>
<li>Progressive Web App installability</li>
<li>Clean modular structure for easy expansion</li>
</ul>
<p>💡 <strong>Next Steps:</strong></p>
<ul>
<li>Add search or filter functionality</li>
<li>Implement user login with JWT or session cookies</li>
<li>Deploy the app online (Render or Vercel + Railway combo)</li>
<li>Add game images and more UI polish</li>
</ul>
<hr>
<h2>🏁 Final Thoughts</h2>
<p>Congratulations 🎉 — you’ve built a working <strong>Progressive Web App</strong> using modern web and backend technologies — all locally, with SQLite as your database.</p>
<p>This guide is now a <strong>complete GitHub-ready educational project</strong>, ideal for showcasing:</p>
<ul>
<li>Full-stack fundamentals</li>
<li>Web + Database integration</li>
<li>PWA best practices</li>
<li>Code organization and documentation</li>
</ul>
<hr>
<p>✅ <strong>End of Full-Stack Annotated Study Guide</strong></p>
<hr>
